//
//  ViewController.swift
//  tsukete
//
//  Created by Kyus'lee on 2022/09/12.
//

import UIKit
import GoogleMaps
import CoreLocation

// „Ç¢„Éó„É™„ÅÆlogic:
// ÊúÄÂàù„ÅØ„ÄÅOnboarding View(„Ç¢„Éó„É™„ÅÆË™¨Êòé)„ÇíË°®Á§∫„Åï„Åõ„Çã
// „Ç¢„Éó„É™„ÅÆË™¨Êòé„ÅÆÁ¢∫Ë™ç„ÅÆÂæå„ÄÅmain page(google map)„Åå„ÅÇ„Çã„Å®„Åì„Å´ÁîªÈù¢ÈÅ∑Áßª

//protocol MainViewDelegate {
//    func isAlreadyClicked(selected: isSelected)
//}

class ViewController: UIViewController {
//
//    var delegate: MainViewDelegate?
    // Ë™¨Êòé„ÅÆview„ÇíË°®Á§∫„Åó„Åü„Åã„ÅÆbool Á∑®Êï∞
    //‚ö†Ô∏èÊ∞∏‰πÖÁöÑ„Å´„Åì„ÅÆÂÄ§„Çí‰øùÂ≠ò„Åó„Åü„ÅÑ„Å™„Çâ„ÄÅlocal„Å´userDefaults„ÇíÁî®„ÅÑ„Å¶Ë®òÊÜ∂„Åï„Åõ„Çã„ÇÇ„ÅÆ„Åå„ÅÇ„Çã
    var didShowOnboardingView = false
    var showLocationRequest = false
    var appearKeyboard = false
    // „ÅäÂ∫ó„ÅÆÂêçÂâç„ÇíÊ§úÁ¥¢„Åß„Éí„ÉÉ„Éà
    var searchText = ""
    // API„Åã„ÇâÊàª„Å£„Å¶„Åç„Åüname„Å®searchText„Çí„Éí„ÉÉ„Éà„Åï„Åõ„ÄÅ„Åù„ÅÆ‰∏≠„ÅÆ‰ΩèÊâÄ„ÇíÊåÅ„Å£„Å¶„Åè„Çã
    var targetAddress = ""
    // „ÅäÂ∫ó„ÅÆÂêçÂâç„ÇíAPI„Åã„Çâ‰∫ãÂâç„Å´ÁôªÈå≤
    var restauName = ""
    let searchBar = UISearchBar(frame: CGRect(x: 0, y: 0, width: 300, height: 0))
    let geocoder = CLGeocoder()
    
    // Server API Model
    // „É™„ÇØ„Ç®„Çπ„Éà„Åó„Åü„ÅäÂ∫ó„Åã„Å©„ÅÜ„Åã
    var requestState = false
    // „Ç§„É°„Éº„Ç∏„Åå„ÅÇ„Çã„Åã„Å©„ÅÜ„Åã
    var imageData = [UIImage]()
    var resultPlaceModel: [PlaceModel] = [PlaceModel]()
    var networkLayer = NetworkLayer()
    
    @IBOutlet weak var cardView: testCustomView! {
        didSet {
            cardView.isHidden = true
        }
    }
    
    private var mapView: GMSMapView!
    
//    private var clusterManager: GMUClusterManager!
    // ‚ö†Ô∏èÁèæÂú®Âú∞„ÇíÊù±‰∫¨„Å´custom Ë®≠ÂÆö
    //35.681223
    //139.767059
    var defaultPositionLat: CLLocationDegrees = 35.681223
    var defaultPositionLng: CLLocationDegrees = 139.767059
    
    override func viewDidLoad() {
        super.viewDidLoad()
        navigateConfigure()
        searchBarConfigure()
        mapConfigure()
        markerConfigure()
        mapView.delegate = self
        self.view.addSubview(mapView)
        self.view.sendSubviewToBack(mapView)
        
        setCardView()
        setCardConstraints()
        self.cardView.delegate = self
        dismissKeyboardByTap()
        // ‚ö†Ô∏èAPI model„Åã„Çâconfigure„Åô„Çã„Å§„ÇÇ„Çä
//        cardView.configure(state: requestState)
        cardViewGesture()
        addKeyboardObserver()
        requestRestaurantAPI()
        requestGetImage()
    }
    
    // Memory Warning
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
    
    // MARK: üî•Ê§úÁ¥¢„Åó„ÅüÂêçÂâç„ÅÆ‰ΩçÁΩÆ„ÇíË™≠„ÅøËæº„ÇÄ
    func getLocation() {
        
    }
    
    // ImageÂÜôÁúü„ÅÆÂá¶ÁêÜ
    // ‚ö†Ô∏è‰ªäÂõû„ÅØ„ÄÅimage„ÅØ‰Ωø„Çè„Å™„ÅÑ„Åì„Å®„Å´„Åó„Åü
    func loadImage(urlString: String, completion: @escaping (UIImage?) -> Void ) {
        networkLayer.request(type: .justURL(urlString: urlString)) { data, response, error in
            if let hasData = data {
                completion(UIImage(data: hasData))
                return
            }
            completion(nil)
        }
    }
    
    func requestRestaurantAPI() {
        //Query String„Çí‰Ωø„Å£„Å¶„ÄÅtargetË¶ÅÁ¥†„ÇíÊåáÂÆö
        // ‰ªäÂõû„ÅØ Query„Å™„Åó„Åß
        // shops„Å†„Åë„ÅßÂøÖË¶Å„Å™ÊÉÖÂ†±„ÅØË™≠„ÅøËæº„ÇÅ„Çã
        let url = "http://localhost:8080/api/shops"
        
        networkLayer.request(type: .justURL(urlString: url)) { data, response, error in
            if let hasData = data {
                
                do {
                    self.resultPlaceModel = try JSONDecoder().decode([PlaceModel].self, from: hasData)
                    
                    // requestAPI„Åã„Çâ‰∫ãÂâç„Å´ÁôªÈå≤
                    self.restauName = self.resultPlaceModel.first?.name ?? ""
                    print(self.restauName)
                    self.getAddressString()
                    
                    DispatchQueue.main.async {
                        // CardView„ÅÆÊÉÖÂ†±„ÇíModel„ÅÆÊÉÖÂ†±„Å´Â§âÊõ¥
                        self.cardView.configure(with: self.resultPlaceModel)
                    }
                    
                } catch {
                    print(error)
                }
            }
        }
    }
    
    func requestGetImage() {
        let imageUrl1 = "http://drive.google.com/uc?export=view&id=1EV5zj7Rz5HG8uUWCvEb8lxehlDPfrACM"
        let imageUrl2 = "http://drive.google.com/uc?export=view&id=1OXit8NrEDtTKea7rxkFN286J7bX20X0K"
        let imageUrl3 = "http://drive.google.com/uc?export=view&id=1q8ORuIudXwedg-DJ8wfHp3fp3yVLUgcF"
        
        // ‚ö†Ô∏èÈÖçÂàó„Åß„ÇÑ„Çç„ÅÜ„Å®„Åó„Åü„Åå„ÄÅ„Åß„Åç„Å™„Åã„Å£„Åü
        self.loadImage(urlString: imageUrl1) { image in
            DispatchQueue.main.async {
                self.cardView.image1.image = image
            }
        }
        
        self.loadImage(urlString: imageUrl2) { image in
            DispatchQueue.main.async {
                self.cardView.image2.image = image
            }
        }
        
        self.loadImage(urlString: imageUrl3) { image in
            DispatchQueue.main.async {
                self.cardView.image3.image = image
            }
        }
    }
    
    func getAddressString() {
        if let hasData = resultPlaceModel.first {
            targetAddress += hasData.prefecture ?? ""
            targetAddress += hasData.locality ?? ""
            targetAddress += hasData.street ?? ""
            targetAddress += hasData.building ?? ""
            print(targetAddress)
        } else {
            return
        }
    }
    
    // ‚ö†Ô∏èsearch buttonÊäº„Åó„Åü„Çâ„ÄÅname„Ååmatch„Åô„Çã„Åã„ÇíÁ¢∫Ë™ç
    // „Åù„ÅÆ„ÅÇ„Å®„ÄÅtargetAddress„Åßgeocoding„Åó„Å¶„ÄÅmap„Å´marker Ë°®Á§∫
    func isMatchedName() -> Bool {
        if searchText == restauName {
            return true
        } else {
            return false
        }
    }
    
    // table View„ÅØ„ÄÅresultPlaceModel[indexPath.row]„Åø„Åü„ÅÑ„Å´„ÇÑ„Çã
    
    private func navigateConfigure() {
        // No title of Navigation Title
        let navigationBarAppearance = UINavigationBarAppearance()
        navigationBarAppearance.backgroundColor = .white
        navigationController?.navigationBar.standardAppearance = navigationBarAppearance
        navigationController?.navigationBar.scrollEdgeAppearance = navigationBarAppearance
        
    }
    
    private func mapConfigure() {
        let camera:GMSCameraPosition = GMSCameraPosition.camera(withLatitude: defaultPositionLat, longitude: defaultPositionLng, zoom: 11)
        mapView = GMSMapView(frame: self.view.bounds, camera: camera)
        mapView.settings.scrollGestures = true
        mapView.settings.zoomGestures = true
        mapView.settings.myLocationButton = true
        mapView.isMyLocationEnabled = true
    }
    
    private func searchBarConfigure() {
        // NavigationItem „Å´ UISearchBarÂÖ•„Çå„Å¶‰Ωú„Çã
        
        searchBar.placeholder = "Â∫óËàóÊ§úÁ¥¢"
        // Â∑¶„ÅÆSearch Image
        searchBar.setImage(UIImage(named: "icSearchNonW"), for: UISearchBar.Icon.search, state: .normal)
        // Âè≥„ÅÆ x „Éú„Çø„É≥„ÅÆImage
        searchBar.setImage(UIImage(named: "icCancel"), for: .clear, state: .normal)
        
        let searchBarButtonItem = UIBarButtonItem(customView: searchBar)
        let profileButtonItem = UIBarButtonItem(image: UIImage(systemName: "person.crop.circle"), style: .plain, target: self, action: #selector(moveToProfilePage))
        self.navigationItem.rightBarButtonItems = [profileButtonItem, searchBarButtonItem]
        
        searchBar.delegate = self
        // cancel Button„ÇíË°®„Åô
        searchBar.showsCancelButton = false
//        searchBar.showsSearchResultsButton = true
    }
    
    @objc func moveToProfilePage(_ sender: UIBarButtonItem) {
        let profileVC = ProfileViewController(nibName: "ProfileViewController", bundle: nil)
        
        if appearKeyboard {
            searchBar.endEditing(true)
            appearKeyboard = false
        }
        
        self.navigationController?.pushViewController(profileVC, animated: true)
        print("mainPage -> profilePage")
    }
    
    private func cardViewGesture() {
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(detailCardViewMove))
        cardView.addGestureRecognizer(tapGesture)
    }
    
    @objc func detailCardViewMove() {
        guard let detailVC = UIStoryboard(name: "DetailCardVC", bundle: nil).instantiateViewController(withIdentifier: "DetailCardVC") as? DetailCardVC else {
            return
        }
        
        // data„ÇídetailVC„Å´Ê∏°„Åô
        detailVC.seatsModelByPlace = resultPlaceModel
        detailVC.restaurantTitle = cardView.restaurantName.text!
        // CoverVertical„ÅÆ„É¢„Éº„Éâ
        detailVC.modalTransitionStyle = .coverVertical
        self.present(detailVC, animated: true, completion: nil)
    }
    
    private func setCardView() {
        cardView.frame = CGRect(x: 0, y: 0, width: 200, height: 300)
    }
    
    private func setCardConstraints() {
        cardView.translatesAutoresizingMaskIntoConstraints = false

        cardView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: -30).isActive = true
        cardView.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true
        cardView.leftAnchor.constraint(equalTo: self.view.leftAnchor, constant: 30).isActive = true
        cardView.rightAnchor.constraint(equalTo: self.view.rightAnchor, constant: -30).isActive = true
    }
    
    private func addKeyboardObserver() {
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name: UIResponder.keyboardWillShowNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name: UIResponder.keyboardWillHideNotification, object: nil)
    }
    
    private func removeKeyboardObserver() {
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc func keyboardWillShow(noti: Notification) {
        guard appearKeyboard == false else {
            return
        }
        appearKeyboard = true
        print(appearKeyboard)
        
        if !self.cardView.isHidden {
            self.cardView.isHidden = true
        }
        
    }
    
    @objc func keyboardWillHide(noti: Notification) {
        guard appearKeyboard == true else {
            return
        }
        
        appearKeyboard = false
        
        print(appearKeyboard)
    }
    
    private func markerConfigure() {
        let position = CLLocationCoordinate2D(latitude: defaultPositionLat, longitude: defaultPositionLng)
        let marker = GMSMarker(position: position)
        marker.title = "Tokyo"
        // marker„ÅÆËâ≤Â§âÊõ¥
        marker.icon = GMSMarker.markerImage(with: .orange.withAlphaComponent(0.5))
        marker.map = mapView
        marker.appearAnimation = .pop
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        if didShowOnboardingView == false {
            didShowOnboardingView = true
            
            let pageVC = OnboardingPageVC(transitionStyle: .scroll, navigationOrientation: .horizontal, options: .none)

            pageVC.modalPresentationStyle = .overCurrentContext
            self.present(pageVC, animated: true, completion: nil)
        }
    }
    
    private func dismissKeyboardByTap() {
        // „Å©„Åì„Åß„ÇÇtap„Åó„Åü„Çâkeyboard„ÅåË°®Á§∫„Åï„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(self.view.endEditing))
        mapView.addGestureRecognizer(tapGesture)
    }
}

extension ViewController: GMSMapViewDelegate {
    // Map View„ÇíTap„Åô„Çã„Åì„Å®„Å´„Çà„ÇãEvent
    func mapView(_ mapView: GMSMapView, didTapAt coordinate: CLLocationCoordinate2D) {
        // Keyboard„Çí‰∏ã„Çç„Åô
        if appearKeyboard {
            print("keyboard is appearing")
            // searchBar „ÅÆÂÖ•Âäõ„Å´„Çà„Çãkeyboard„ÅåÁèæ„Çå„Åü„Çâ„ÄÅ‰∏ã„Çç„Åô
            searchBar.endEditing(true)
            appearKeyboard = false
        }
        
        
        if cardView.isHidden == false {
            print("true")
            mapView.settings.myLocationButton = true
            cardView.isHidden = true
        } else {
            print("false")
            return
        }
    }
    
    // Marker„ÇíTap„Åó„Åü„ÇâÂëº„Å≥Âá∫„Åï„Çå„Çã„É°„ÇΩ„ÉÉ„Éâ
    func mapView(_ mapView: GMSMapView, didTap marker: GMSMarker) -> Bool {
        print("You tapped at \(marker.position.latitude), \(marker.position.longitude)")
        cardView.isHidden = false
        mapView.settings.myLocationButton = false
        return true
    }
}

// MARK: SearchBar Èñ¢ÈÄ£
// ‚ö†Ô∏èGoogle Place API Â†¥ÊâÄÊ§úÁ¥¢„Åß„ÅäÂ∫ó„Çí„Éí„ÉÉ„Éà„Åô„Çã„Å§„ÇÇ„Çä
extension ViewController: UISearchBarDelegate, UISearchResultsUpdating {
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        guard let hasText = searchBar.text else {
            return
        }
        print("search")
        
        searchText = hasText
        if isMatchedName() {
            print("true: \(restauName)")
            // MARK: üî• search„Åó„Å¶„ÄÅ„Éí„ÉÉ„Éà„Åó„Åü„ÇâGeoCoding„ÇíË°å„ÅÜ
            
        }
        
        print(searchText)
    }
    
    func updateSearchResults(for searchController: UISearchController) {
        guard let hasText = searchController.searchBar.text else {
            return
        }
        print(hasText)
    }
    

    
    // search bar touchÂæå„ÄÅÂÖ•Âäõ„ÇíÂßã„ÇÅ„Åü„Å®„Åç„Å´Âëº„Å≥Âá∫„Åï„Çå„Çã„É°„ÇΩ„ÉÉ„Éâ
    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
        if !searchBar.showsCancelButton {
            searchBar.showsCancelButton = true
        }
        
        print("search Start!")
    }
    
    // cancel button clickÊôÇ„Å´Âëº„Å≥Âá∫„Åï„Çå„Çã„É°„ÇΩ„ÉÉ„Éâ
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        if searchBar.showsCancelButton {
            searchBar.showsCancelButton = false
        }
        
        searchBar.endEditing(true)
    }
    
    // Ê§úÁ¥¢ÂÖ•ÂäõÂÄ§„ÅåÁ∑®ÈõÜ„Åï„Çå„Çã„Åü„Å≥„Å´Âëº„Å≥Âá∫„Åï„Çå„Çã„É°„ÇΩ„ÉÉ„Éâ
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        guard let hasText = searchBar.text else {
            return
        }
        
        print(hasText)
        print(searchText)
    }
    
}

extension ViewController: cardViewDelegate {
    func requestButtonEvent() {
        print("mainPage -> RequestPage")
        print("button tapped!")
    }
    
    func hartButtonEvent() {
        if cardView.hartButtonState == .normal {
            cardView.hartButtonState = .selected
            cardView.setHartButton()
            cardView.hartButton.layer.add(cardView.bounceAnimation, forKey: nil)
            print("normal -> selected")
        } else {
            cardView.hartButtonState = .normal
            cardView.setHartButton()
            cardView.hartButton.layer.add(cardView.bounceAnimation, forKey: nil)
            print("selected -> normal")
        }
        
        // DetailCardVC„Å´„ÇÇÊ∏°„Åô„Åü„ÇÅ„ÅÆlogic„ÇíËøΩÂä†
    }
}








//        clusterConfig()
//        clusterManager.setDelegate(self, mapDelegate: self)
    
    // ‚ö†Ô∏èmodel„Å´„Çà„Å£„Å¶„ÄÅÂ∏∞„Çã„Å§„ÇÇ„Çä
//    func configure() {
//        // serverAPI„ÅÆresult„Å´Âêà„Çè„Åõ„Å¶ config
//        if !imageData.isEmpty {
//            // Image„Çí3„Å§„Å´Áµû„Çã
//            // ‚ö†Ô∏èÈÄî‰∏≠„ÅÆÊÆµÈöé:Image URLÂá¶ÁêÜ„Çí„Åæ„Å†
//            cardView.image1.image = imageData[0]
//            cardView.image2.image = imageData[1]
//            cardView.image3.image = imageData[2]
//        } else {
//            cardView.image1.image = UIImage(systemName: "photo")?.withTintColor(.lightGray)
//            cardView.image2.image = UIImage(systemName: "photo")?.withTintColor(.lightGray)
//            cardView.image3.image = UIImage(systemName: "photo")?.withTintColor(.lightGray)
//        }
//
//        if requestState == false {
//            cardView.restaurantName.text = "SansanÈ£üÂ†Ç"
//            cardView.openTime.text = "Open: 10:00AM"
//            cardView.closeTime.text = "Close: 20:00PM"
//            cardView.vacancyState.text = "„Ç´„É°„É©„ÇíË®≠ÁΩÆ„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì"
//            cardView.vacancyState.textColor = .lightGray
//            cardView.vacancyState.font = UIFont.systemFont(ofSize: 15, weight: .medium)
//        } else {
//            cardView.restaurantName.text = "SansanÈ£üÂ†Ç"
//            cardView.openTime.text = "Open: 10:00AM"
//            cardView.closeTime.text = "Close: 20:00PM"
//            cardView.vacancyState.text = "Á©∫„Åç„ÅÇ„Çä"
//            cardView.vacancyState.textColor = UIColor(rgb: 0x06B3EA)
//            cardView.vacancyState.font = UIFont.systemFont(ofSize: 15, weight: .medium)
//            cardView.requestButton.isHidden = true
//        }
//    }



//    func setSearchBar2(){
//         //ÏÑúÏπòÎ∞î ÎßåÎì§Í∏∞
//         let searchBar = UISearchBar()
//         searchBar.placeholder = "Search"
//         //ÏôºÏ™Ω ÏÑúÏπòÏïÑÏù¥ÏΩò Ïù¥ÎØ∏ÏßÄ ÏÑ∏ÌåÖÌïòÍ∏∞
//         searchBar.setImage(UIImage(named: "icSearchNonW"), for: UISearchBar.Icon.search, state: .normal)
//         //Ïò§Î•∏Ï™Ω xÎ≤ÑÌäº Ïù¥ÎØ∏ÏßÄ ÏÑ∏ÌåÖÌïòÍ∏∞
//         searchBar.setImage(UIImage(named: "icCancel"), for: .clear, state: .normal)
//         //ÎÑ§ÎπÑÍ≤åÏù¥ÏÖòÏóê ÏÑúÏπòÎ∞î ÎÑ£Í∏∞
//        self.navigationItem.titleView = searchBar
//
//         if let textfield = searchBar.value(forKey: "searchField") as? UITextField {
//             //ÏÑúÏπòÎ∞î Î∞±Í∑∏ÎùºÏö¥Îìú Ïª¨Îü¨
//             textfield.backgroundColor = UIColor.black
//             //ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî Í∏ÄÏî® ÏÉâ Ï†ïÌïòÍ∏∞
//             textfield.attributedPlaceholder = NSAttributedString(string: textfield.placeholder ?? "", attributes: [NSAttributedString.Key.foregroundColor : UIColor.lightGray])
//             //ÏÑúÏπòÎ∞î ÌÖçÏä§Ìä∏ÏûÖÎ†•Ïãú ÏÉâ Ï†ïÌïòÍ∏∞
//             textfield.textColor = UIColor.white
//             //ÏôºÏ™Ω ÏïÑÏù¥ÏΩò Ïù¥ÎØ∏ÏßÄÎÑ£Í∏∞
//             if let leftView = textfield.leftView as? UIImageView {
//                 leftView.image = leftView.image?.withRenderingMode(.alwaysTemplate)
//                 //Ïù¥ÎØ∏ÏßÄ Ìã¥Ìä∏Ïª¨Îü¨ Ï†ïÌïòÍ∏∞
//                 leftView.tintColor = UIColor.white
//             }
//             //Ïò§Î•∏Ï™Ω xÎ≤ÑÌäº Ïù¥ÎØ∏ÏßÄÎÑ£Í∏∞
//             if let rightView = textfield.rightView as? UIImageView {
//                 rightView.image = rightView.image?.withRenderingMode(.alwaysTemplate)
//                 //Ïù¥ÎØ∏ÏßÄ Ìã¥Ìä∏ Ï†ïÌïòÍ∏∞
//                 rightView.tintColor = UIColor.white
//             }
//
//         }
//     }

// Cluster„ÅÆÊñπ _ ÂÆüË£ÖÈÄî‰∏≠


// Cluster„Å´Èñ¢„Åô„Çã„ÇÑ„Å§

//        if let poiItem = marker.userData as? POIItem {
//            NSLog("Did tap marker for cluster item \(poiItem)")
//        } else {
//            NSLog("Did tap a normal marker")
//        }
//        return false

//
//extension ViewController: GMUClusterManagerDelegate {
//    // MARK: - GMUClusterManagerDelegate
//    private func clusterManager(_ clusterManager: GMUClusterManager, didTap cluster: GMUCluster) {
//        let newCamera = GMSCameraPosition.camera(withTarget: cluster.position, zoom: mapView.camera.zoom + 1)
//        let update = GMSCameraUpdate.setCamera(newCamera)
//        mapView.moveCamera(update)
//    }
//
//}
//    func clusterConfig() {
//        let iconGenerator = GMUDefaultClusterIconGenerator()
//        let algorithm = GMUNonHierarchicalDistanceBasedAlgorithm()
//        let renderer = GMUDefaultClusterRenderer(mapView: mapView, clusterIconGenerator: iconGenerator)
//        clusterManager = GMUClusterManager(map: mapView, algorithm: algorithm, renderer: renderer)
//
//        // „Éû„Éº„Ç´„Éº„Çí„É©„É≥„ÉÄ„É†„Å´ÁîüÊàê„Åó„Å¶ Map ‰∏ä„Å´Ë°®Á§∫
//        generateClusterItems()
//    }
//
//    private func generateClusterItems() {
//        let extent = 0.01
//        for _ in 1...100 {
//            let lat = defaultPositionLat + extent * randomScale()
//            let lng = defaultPositionLng + extent * randomScale()
//            let item = POIItem(position: CLLocationCoordinate2DMake(lat, lng))
//            clusterManager.add(item)
//        }
//           // Map „Å´„Éû„Éº„Ç´„Éº„ÇíÊèèÁîª
//           clusterManager.cluster()
//    }
//
//    private func randomScale() -> Double {
//        return Double(arc4random()) / Double(UINT32_MAX) * 2.0 - 1.0
//    }


